################################################################################################
##
#W randomgen.gi      GAP Quickcheck     Victor Vasilyev
##
## Implementation of random argument generator functions for the GAP Quickcheck package.
##
#Y Copyright (C) 2018 Univerisity of St. Andrews, North Haugh, St. Andrews, Fife
#Y                                                KY16 9SS, Scotland
##

LoadPackage("Digraph");

################################################################################################
##
#F QuickcheckInt(<max>,<randomsource>) generates an integer of maximum size <max> with the
## random source <randomsource>.
##                                              
InstallGlobalFunction(QuickcheckInt, function(max, randomsource)
  return Random(randomsource, [1..max]);
end);

################################################################################################
##
#F QuickcheckList(<generator>) returns a function that, given a maximum size and a random source,
## generates a list of objects generated by the <generator>. <generator> must take two arguments,
## a maximum size and a random source.
##                                              
InstallGlobalFunction(QuickcheckList, function(generator)
  return function(max, randomsource)
    local length, result, i;
    length := Random(randomsource, [1..max]);
    result := [];
    for i in [1..length] do
      Add(result, generator(max, randomsource));
    od;
    return result;
  end;
end);

################################################################################################
##
#F QuickcheckSet(<generator>) returns a function that, given a maximum size and a random source,
## generates a set of objects generated by the <generator>. <generator> must take two arguments,
## a maximum size and a random source.
##                                              
InstallGlobalFunction(QuickcheckSet, function(generator)
  return function(max, randomsource)
    local length, result, i, member;
    length := Random(randomsource, [1..max]);
    result := [];
    for i in [0..length] do
      member := generator(max, randomsource);
      while member in result do
        member := generator(max, randomsource);
      od;
      Add(result, member);
    od;
    return Set(result);
  end;
end);

################################################################################################
##
#F QuickcheckObject(<constructor>, <arg_gens>) returns a function that, given a maximum size and 
## a random source, generates an object with <constructor>, whose arguments are generated
## by <arg_gens>. <arg_gens> must be a list of functions, each of which takes a maximum size and
## a random source.
##                                              
InstallGlobalFunction(QuickcheckObject, function(constructor, arg_gens)
  return function(max, randomsource)
    local arg, arg_list;
    arg_list := [];
    for arg in arg_gens do
      Add(arg_list, arg(max, randomsource));
    od;
    return CallFuncList(constructor, arg_list);
  end;
end);

################################################################################################
##
#F QuickcheckRecord(<attribute_names>, <arg_gens>) returns a function that, given a maximum size 
## and a random source, generates a record whose fields have the names given by <attribute_names>
## and values generated by <arg_gens>. <arg_gens> is a list of functions, each of which takes a
## maximum size and a random source.
##                                              
InstallGlobalFunction(QuickcheckRecord, function(attribute_names, arg_gens)
  return function(max, randomsource)
    local result, i;
    result := rec();
    for i in [1..Length(arg_gens)] do
      result.(attribute_names[i]) := arg_gens[i](max, randomsource);
    od;
    return result;
  end;
end);

################################################################################################
##
#F QuickcheckPermutation(<max>, <randomsource>) generates a permutation of maximum size <max>
## with the random source <randomsource> using Floyd's algorithm.
##                                              
InstallGlobalFunction(QuickcheckPermutation, function(max, randomsource)
  return PermList(FLOYDS_ALGORITHM(randomsource,max,true));
end);

################################################################################################
##
#F QuickcheckAbelianGroup(<max>, <randomsource>) generates an Abelian group of maximum size <max>
## with the random source <randomsource> by generating a list of random integers and using those
## to construct the group.
##                                              
InstallGlobalFunction(QuickcheckAbelianGroup, function(max, randomsource)
  local i, size, ints;
  size := Random(randomsource, [1..max]);
  ints := [];
  for i in [0..size] do
    Add(ints, Random(randomsource, [1..max]));
  od;
  return AbelianGroup(ints);
end);

################################################################################################
##
#F QuickcheckQuaternionGroup(<max>, <randomsource>) generates a quaternion group of maximum size 
## <max> rounded up to the nearest multiple of 4.
##                                              
InstallGlobalFunction(QuickcheckQuaternionGroup, function(max, randomsource)
  local rounded_size;
  rounded_size := max;
  while rounded_size mod 4 <> 0 do
    rounded_size := rounded_size + 1;
  od;
  return QuaternionGroup(rounded_size);
end);

################################################################################################
##
#F QuickcheckDihedralGroup(<max>, <randomsource>) generates a dihedral group of maximum size 
## <max> rounded up to the nearest multiple of 4.
##                                              
InstallGlobalFunction(QuickcheckDihedralGroup, function(max, randomsource)
  local rounded_size;
  rounded_size := max;
  while rounded_size mod 4 <> 0 do
    rounded_size := rounded_size + 1;
  od;
  return DihedralGroup(rounded_size);
end);

################################################################################################
##
#F QuickcheckPermutationGroup(<max>, <randomsource>) generates a permutation group by creating a
## list of permutations of maximum size <max> using the random source <randomsource> and 
## constructing the group using that list.
##                                              
InstallGlobalFunction(QuickcheckPermutationGroup, function(max, randomsource)
  local length, permutation_list, i;
  length := Random(randomsource, [1..max]);
  permutation_list := [];
  for i in [1..length] do
    Add(permutation_list, QuickcheckPermutation(max, randomsource));
  od;
  return CallFuncList(Group, permutation_list);
end);

################################################################################################
##
#F QuickcheckSmallPermutationGroup(<max>, <randomsource>) generates a permutation group by 
## selecting a random group of size <max> from the Small Groups package.
##                                              
InstallGlobalFunction(QuickcheckSmallPermutationGroup, function(max, randomsource)
  local size, number;
  size := Random(randomsource, [1..max]);
  number := Random(randomsource, [1..NrSmallGroups(size)]);
  return Range(IsomorphismPermGroup(SmallGroup(size,number)));
end);

################################################################################################
##
#F QuickcheckCoset(<max>, <randomsource>) generates a coset by generating a random permutation
## group and a random permutation and multiplying one by the other.
##                                              
InstallGlobalFunction(QuickcheckCoset, function(max, randomsource)
  return QuickcheckPermutationGroup(max, randomsource) * QuickcheckPermutation(max,randomsource);
end);

################################################################################################
##
#F QuickcheckDigraph(<max>, <randomsource>) generates a digraph by generating a range of 
## enumerated nodes of maximum size <max> and source and range lists from that list.
##                                              
InstallGlobalFunction(QuickcheckDigraph, function(max, randomsource)
  local length, nodes, no_links, source, range, i;
  length := Random(randomsource, [1..max]);
  no_links := Random(randomsource, [1..length]);
  nodes := [1..length];
  source := [];
  range := [];
  for i in [1..no_links] do
    Add(source, Random(randomsource, nodes));
    Add(range, Random(randomsource, nodes));
  od;
  return Digraph(nodes, source, range);
end);

################################################################################################
##
#F QuickcheckCyclicGroup(<max>, <randomsource>) generates the cyclic group of size <max>.
##                                              
InstallGlobalFunction(QuickcheckCyclicGroup, function(max, randomsource)
  return CyclicGroup(max);
end);

################################################################################################
##
#F QuickcheckFreeAbelianGroup(<max>, <randomsource>) generates the free Abelian group of size 
## <max>.
##                                              
InstallGlobalFunction(QuickcheckFreeAbelianGroup, function(max, randomsource)
  return FreeAbelianGroup(max);
end);

################################################################################################
##
#F QuickcheckGroup(<max>, <randomsource>) selects a random group constructor and calls it with
## <max> and <randomsource>.
##                                              
InstallGlobalFunction(QuickcheckGroup, function(max, randomsource)
  local type, size, group_types;
  group_types := [
    QuickcheckCyclicGroup,
    QuickcheckAbelianGroup,
    QuickcheckFreeAbelianGroup,
    QuickcheckDihedralGroup,
    QuickcheckQuaternionGroup,
    QuickcheckPermutationGroup,
    QuickcheckSmallPermutationGroup
  ];
  type := Random(randomsource, [1..Length(group_types)]);
  size := Random(randomsource, [1..max]);
  return group_types[type](size, randomsource);
end);

#E randomgen.gi end here
