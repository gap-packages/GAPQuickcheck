  
  [1X3 [33X[0;0YArgument Generators[133X[101X
  
  [33X[0;0YFunctions  in  GAP  Quickcheck are tested with random arguments. In order to
  provide  those  arguments, the package defines generator functions that take
  in  two  arguments- a maximum size and a random source. From now on, we will
  refer  to  functions  of that form as generator functions. The random source
  has  to  be  provided so that he testing engine has a possibility of caching
  seeds that result in failing tests.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xrs := RandomSource(IsMersenneTwister, 42);[127X[104X
    [4X[25Xgap>[125X [27XPrint(QuickcheckInt(10, rs), "\n");[127X[104X
    [4X[25Xgap>[125X [27XPrint(QuickcheckPermutation(10, rs), "\n");[127X[104X
    [4X[25Xgap>[125X [27XPrint(QuickcheckSmallPermutationGroup(10, rs), "\n");[127X[104X
  [4X[32X[104X
  
  [33X[0;0YGenerators  are simply passed to the Expect function, which creates a random
  source and constructs arguments for the tested function.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XExpect(Size)[127X[104X
    [4X[25X>[125X [27X.given([QuickcheckGroup])[127X[104X
    [4X[25X>[125X [27X.to_not_break();[127X[104X
  [4X[32X[104X
  
  [33X[0;0YThe  package  also  exposes  functions for creating composite arguments. The
  simplest  of  these  are  list  and  set  generators.  They take a generator
  function and return a generator function:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xlistgen := QuickcheckList(QuickcheckInt);[127X[104X
    [4X[25Xgap>[125X [27XPrint(listgen(10, rs), "\n");[127X[104X
    [4X[25Xgap>[125X [27Xsetgen := QuickcheckSet(QuickcheckInt);[127X[104X
    [4X[25Xgap>[125X [27XPrint(setgen(10, rs), "\n");[127X[104X
  [4X[32X[104X
  
  [33X[0;0YOne  can also generate more complex objects using the object generator. This
  takes  in  a  constructor  and  a list of arguments generators and creates a
  generator  function  for the specific object. For example, one can construct
  an Abelian Group this way (although a generator for it is already defined in
  the package).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xabeliangen := QuickcheckObject(AbelianGroup, [QuickcheckList(QuickcheckInt)]);[127X[104X
    [4X[25Xgap>[125X [27XPrint(abeliangen(10, rs), "\n");[127X[104X
  [4X[32X[104X
  
  [33X[0;0YFinally,  a  user  can  define their own generators. As mentioned earlier, a
  generator is a function that takes in a maximum size and a random source and
  produces an object. We can therefore define a new generator for positive and
  negative integers.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XPosAndNegIntGen := function(max, randomsource)[127X[104X
    [4X[25X>[125X [27X  local coin;[127X[104X
    [4X[25Xgap>[125X [27X  coin := Random(randomsource, [0..1]);[127X[104X
    [4X[25Xgap>[125X [27X  if coin = 0 then[127X[104X
    [4X[25X>[125X [27X    return -QuickcheckInt(max, randomsource);[127X[104X
    [4X[25Xgap>[125X [27X  else[127X[104X
    [4X[25X>[125X [27X    return QuickcheckInt(max, randomsource);[127X[104X
    [4X[25Xgap>[125X [27X  fi;[127X[104X
    [4X[25Xgap>[125X [27Xend;[127X[104X
    [4X[25Xgap>[125X [27XPrint(QuickcheckList(PosAndNegIntGen)(10, rs), "\n");[127X[104X
  [4X[32X[104X
  
